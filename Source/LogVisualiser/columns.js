const ColumnTypes = {    Timestamp : "Time Stamp",    LogLevel : "Level",    Thread : "Thread",    Class : "Class",    NonPattern : ""};const columnTypeRegex = [];columnTypeRegex[ColumnTypes.Timestamp] = [/\d{4}?\D\d{1,2}?\D\d{1,2} \d{1,2}?:\d{1,2}?:\d{1,2}(\D\d*)?/g];columnTypeRegex[ColumnTypes.LogLevel] = [/( |\W)(trace|debug|info|warn|error|fatal)( |\W)/i];//columnTypeRegex[ColumnTypes.Class]//columnTypeRegex[ColumnTypes.Thread]// TODO: Dont add columnTypeRegex[ColumnTypes.NonPattern] - this way it never macthes!function Column(type, ordinal) {    this.type = type;    this.ordinal = ordinal;}module.exports = function Columns() {    this.columns = [];    this.discoverColumns = function(line) {        // Starting at pos 0 of the lines string - look for all patterns        // Remember the pattern that has the first match and the position        // mmm do we just want to find all column matches.. or avoid overlapping columns..... I think we need a list of columns in expected order. yeah.. so        // recursively discover on the remainder of the line - that is start pos + match width        // Some columnTypeRegex will be arrays        var columnIndex = 0;        var failedToMatch = false;        while(failedToMatch === false) {            var result;            for (var typeKey in columnTypeRegex) {                if (columnTypeRegex.hasOwnProperty(typeKey)) {                    var patterns = columnTypeRegex[typeKey];                    for (var index = 0; index < patterns.length; index++) {                        result = patterns.exec(line);                        if (result.index >= 0) {                            // Don't match any more of the same type                            break;                        }                    }                    if (result.index >= 0) {                        // Don't match any more types                        break;                    }                }            }            if(result.index >= 0) {                // TODO: The characters between the last matcg (or 0) and this must be a non pattern column - add that (of one not already at this index                // TODO: Only add this column if not already discovered... (but carry on looking as if we did - there may be a unqiue column at the end) - .equals??                this.columns.push(new Column(typeKey, columnIndex++));            } else {                // TODO: the characters between the last match and the end must be a non pattern column - add if not already.                // No columns matched - exit the while                failedToMatch = true;            }        }    }}